A function that “remembers” the variables from the scope in which it was defined — 
even after that scope has finished executing.


Closures aren’t formed when you just write nested functions.
They're formed when you call the outer function, and  it defines the inner one — that’s
when the closure is “born” and locks onto the variables in that specific call.


difference between closure and scope:-

Scope: Controls access to a variable like decides which variable is accesible by which part of code.

Closure: Keeps track of variable even when the outer function is done with excuting

Garbage Collection:-JavaScript doesn’t garbage collect outer function’s variables if they’re still referenced 
by an inner function that is still in use (e.g., returned, stored, or passed elsewhere).
That inner function closes over the variables — and this is what forms a closure.

:- "garbage collected" means that the memory used by variables or objects that are no longer needed 
 is automatically freed up by the JavaScript engine.

HOF and Closure:-
HOFs and closures are complementary to each other. Higher-order functions provide a way to 
create functions dynamically, and closures allow those functions to retain access to their 
lexical environment (variables from the outer function). You can’t fully leverage the power 
of higher-order functions without closures, because the returned functions often need to "remember" 
values, and closures make that possible.