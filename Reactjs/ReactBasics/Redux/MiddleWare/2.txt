========================================
WHAT IS A THUNK?
========================================

DEFINITION:
It allows you to write action creators that 
return a function instead of an plain object when calling dispatch function.
That function can perform asynchronous tasks (like API calls) and then dispatch 
normal actions when ready.
Without thunk (or another async middleware), Redux can only handle plain action objects.

SHAPE:
const someThunk = (args) => async (dispatch, getState) => {
  // async work here
  dispatch({ type: 'some/action', payload: data });
};

import { createStore, applyMiddleware } from "redux";
import thunk from "redux-thunk";

// 2. Reducer
const initialState = { user: null, loading: false };
const reducer = (state = initialState, action) => {
  switch (action.type) {
    case "FETCH_USER_START":
      return { ...state, loading: true };
    case "FETCH_USER_SUCCESS":
      return { ...state, loading: false, user: action.payload };
    default:
      return state;
  }
};

// 3. Async action creator using thunk
const fetchUser = (id) => {
  return (dispatch) => {
    dispatch({ type: "FETCH_USER_START" }); // optional loading state

    fetch(`https://jsonplaceholder.typicode.com/users/${id}`)
      .then((res) => res.json())
      .then((data) => {
        dispatch({ type: "FETCH_USER_SUCCESS", payload: data });
      });
  };
};

// 4. Create store with thunk middleware
const store = createStore(reducer, applyMiddleware(thunk));

// 5. Dispatch the async action
store.dispatch(fetchUser(1));

// 6. Subscribe to see changes
store.subscribe(() => console.log(store.getState()));

APPLY MULTIPLE MIDDLEWARE:
const store = createStore(usersReducer, applyMiddleware(thunk, logger));

========================================
ERROR HANDLING & CANCELLATION
========================================

BASIC ERROR HANDLING:
- Try/catch in thunks
- Dispatch a clear failure action
- Store human-readable error messages
- Show error UI based on state.error

CANCELLATION (SIMPLE):
- Track a requestId in state
- When a new fetch starts, store requestId
- After fetch resolves, only dispatch success if requestId matches latest
- For complex cancellation, consider advanced tools later

========================================
BEST PRACTICES
========================================

- Keep reducers pure; no fetch or side effects in reducers
- Dispatch a started action before async work
- Always handle success and failure actions
- Keep action types descriptive: "domain/event" (e.g., "users/fetchSucceeded")
- Derive loading/error UI from state (no ad-hoc flags in components)
- Keep thunks small; delegate complex transformations to pure helpers

========================================
COMMON PITFALLS
========================================

- Forgetting to return new state in reducers (immutability)
- Dispatching non-serializable payloads (stick to JSON-serializable)
- Swallowing errors silently (always dispatch failure)
- Over-selecting with useSelector (select only what you need)
- Triggering repeated requests in useEffect without stable deps

========================================
NEXT:
- Step 8: Redux Toolkit basics (configureStore, createSlice, createAsyncThunk)
- Convert the above example to Redux Toolkit for cleaner, modern code
